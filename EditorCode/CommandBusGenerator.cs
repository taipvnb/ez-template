using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using UnityEditor;
using UnityEngine;

namespace com.ez.engine.services.command_bus.editor
{
    internal class CommandBusGenerator : AssetPostprocessor
    {
        private const string GeneratePath = "Scripts/Generated";
        private const string CommandBusFileName = "CommandBusExtensions";

        private static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets, string[] movedAssets, string[] movedFromAssetPaths)
        {
            var isCommandClass = importedAssets.Any(IsCommandClass) ||
                                 deletedAssets.Any(IsCommandClass) ||
                                 movedAssets.Any(IsCommandClass) ||
                                 movedFromAssetPaths.Any(IsCommandClass);

            if (isCommandClass)
            {
                // GenerateCode();
            }
        }

        private static bool IsCommandClass(string path)
        {
            if (path.Contains(".cs"))
            {
                if (File.Exists(path))
                {
                    var lines = File.ReadAllLines(path);
                    foreach (var line in lines)
                    {
                        if (line.Contains(":") && line.Contains("ICommand"))
                        {
                            return true;
                        }
                    }
                }
            }

            return false;
        }

        [MenuItem("Unimob/CodeGen/Command Bus Extensions")]
        private static void GenerateCode()
        {
            var saveFolderPath = Path.Combine(Application.dataPath, GeneratePath);
            var saveFilePath = Path.Combine(saveFolderPath, CommandBusFileName + ".cs");
            
            if (!Directory.Exists(saveFolderPath))
            {
                Directory.CreateDirectory(saveFolderPath);
            }
            
            if (File.Exists(saveFilePath))
            {
                File.Delete(saveFilePath);
            }
            
            if (File.Exists(saveFilePath + ".meta"))
            {
                File.Delete(saveFilePath + ".meta");
            }
            
            AssetDatabase.Refresh(ImportAssetOptions.ForceUpdate);
            AssetDatabase.SaveAssets();
            
            var builder = new StringBuilder();
            builder.Append("using Cysharp.Threading.Tasks;").Append("\n");
            
            var content = GenerateCommandExtensionsContent(out var namespaces);
            foreach (var ns in namespaces)
            {
                builder.Append($"using {ns};");
            }
            
            if (namespaces.Count > 0)
            {
                builder.Append("\n");
            }
            
            builder.Append(content);
            File.WriteAllText(saveFilePath, builder.ToString(), Encoding.UTF8);
            AssetDatabase.ImportAsset(Path.Combine("Assets", GeneratePath, $"{CommandBusFileName}.cs"));
            AssetDatabase.Refresh(ImportAssetOptions.ForceUpdate);
            AssetDatabase.SaveAssets();
        }

        private static string GenerateCommandExtensionsContent(out List<string> namespaces)
        {
            namespaces = new List<string>();
            var builder = new StringBuilder();
            builder.Append("\n");
            builder.Append("namespace com.ez.engine.services.command_bus").Append("\n");
            builder.Append("{").Append("\n");

            var assetPaths = AssetDatabase.GetAllAssetPaths();
            var commands = GetAllTypesImpInterface<ICommand>();
            foreach (var assetPath in assetPaths)
            {
                if (assetPath.Contains(".cs"))
                {
                    foreach (var command in commands)
                    {
                        if (command.Name.Equals(Path.GetFileNameWithoutExtension(assetPath)))
                        {
                            var path = assetPath.Replace("\\", "/");
                            if (File.Exists(path))
                            {
                                var handlers = GetAllTypesImpICommandHandler(command);
                                if (handlers.Count > 0)
                                {
                                    var handler = handlers[0];
                                    if (!string.IsNullOrEmpty(handler.Namespace) && !namespaces.Contains(handler.Namespace))
                                    {
                                        namespaces.Add(handler.Namespace);
                                    }

                                    builder.Append("\t").Append("///<auto-generated/>").Append("\n");
                                    builder.Append("\t").AppendFormat("public static class {0}Extensions", handler.Name).Append("\n");
                                    builder.Append("\t").Append("{").Append("\n");
                                    builder.Append("\t\t").Append(GenerateCommandExtensionsMethod(command, handler)).Append("\n");
                                    builder.Append("\t").Append("}").Append("\n");
                                    builder.Append("\n");
                                }
                            }
                        }
                    }
                }
            }

            builder.Append("}");
            return builder.ToString();
        }

        private static string GenerateCommandExtensionsMethod(Type commandType, Type handlerType)
        {
            return $@"///<auto-generated/>
        public static void Register_{handlerType.Name}(this ICommandBusService commandBusService, {handlerType.Name} handler)
        {{
            commandBusService.Register(handler);
        }}
        
        ///<auto-generated/>
        public static void UnRegister_{handlerType.Name}(this ICommandBusService commandBusService)
        {{
            commandBusService.UnRegister<{handlerType.Name}>();
        }}
        {(IsCommand1(commandType) ? GenerateCommandExecuteExtensionsMethod1(commandType, handlerType) : "")}
        {(IsCommand2(commandType) ? GenerateCommandExecuteExtensionsMethod2(commandType, handlerType) : "")}
        ";
        }

        private static string GenerateCommandExecuteExtensionsMethod1(Type commandType, Type handlerType)
        {
            return $@"///<auto-generated/>
        public static UniTask Execute_{handlerType.Name}(this ICommandBusService commandBusService, {commandType.Name} command)
        {{
            return commandBusService.Execute(command);
        }}";
        }

        private static string GenerateCommandExecuteExtensionsMethod2(Type commandType, Type handlerType)
        {
            var responseType = commandType.GetInterfaces().FirstOrDefault(i => i.IsGenericType && i.GetGenericTypeDefinition() == typeof(ICommand<>))
                ?.GetGenericArguments()[0];
            return $@"///<auto-generated/>
        public static UniTask<{responseType.Name}> Execute_{handlerType.Name}(this ICommandBusService commandBusService, {commandType.Name} command)
        {{
            return commandBusService.Execute<{commandType.Name},{responseType.Name}>(command);
        }}";
        }

        private static bool IsCommand1(Type type)
        {
            return typeof(ICommand).IsAssignableFrom(type) && type.GetInterfaces().Length == 1;
        }

        private static bool IsCommand2(Type type)
        {
            return typeof(ICommand).IsAssignableFrom(type) &&
                   type.GetInterfaces().Any(i => i.IsGenericType && i.GetGenericTypeDefinition() == typeof(ICommand<>));
        }

        private static List<Type> GetAllTypesImpICommandHandler(Type commandType)
        {
            var genericICommandHandler1 = typeof(ICommandHandler<>);
            var genericICommandHandler2 = typeof(ICommandHandler<,>);
            var assemblies = AppDomain.CurrentDomain.GetAssemblies();
            var implementingTypes = assemblies
                .SelectMany(assembly => assembly.GetTypes())
                .Where(type => type.GetInterfaces().Any(i =>
                    i.IsGenericType &&
                    ((i.GetGenericTypeDefinition() == genericICommandHandler1 &&
                      i.GetGenericArguments().Length == 1 &&
                      i.GetGenericArguments()[0] == commandType) ||
                     (i.GetGenericTypeDefinition() == genericICommandHandler2 &&
                      i.GetGenericArguments().Length == 2 &&
                      i.GetGenericArguments()[0] == commandType))
                )).ToList();
            return implementingTypes;
        }

        private static IEnumerable<Type> GetAllTypesImpInterface<TInterface>()
        {
            var results = new List<Type>();
            var types = GetTypesImplementInterface<TInterface>();

            foreach (var type in types)
            {
                if (type.IsGenericType)
                {
                    try
                    {
                        results.AddRange(from typeArgument in type.GetGenericArguments()
                            from typeConstraint in typeArgument.GetGenericParameterConstraints()
                            from genericType in GetAllGenericTypes(type, typeConstraint)
                            select genericType);
                    }
                    catch (StackOverflowException e)
                    {
                        Debug.LogError($"[{nameof(CommandBusGenerator)}] Ignore type {type.Name} that caused stack overflow. {e.Message}");
                    }
                }
                else
                {
                    results.Add(type);
                }
            }

            return results;
        }

        private static IEnumerable<Type> GetAllGenericTypes(Type classType, Type constrainedType)
        {
            var possibleArgumentTypes = GetTypesImplementInterface(constrainedType);
            return possibleArgumentTypes.Select(argumentType => classType.MakeGenericType(argumentType)).ToList();
        }

        private static IEnumerable<Type> GetTypesImplementInterface<TInterface>()
        {
            return AppDomain.CurrentDomain.GetAssemblies().SelectMany(x => x.GetTypes())
                .Where(x => (typeof(TInterface).IsAssignableFrom(x)
                             || x.GetInterfaces().Any(i => i.IsGenericType && i.GetGenericTypeDefinition() == typeof(ICommand<>)))
                            && !x.IsInterface
                            && !x.IsAbstract)
                .Select(x => x);
        }

        private static IEnumerable<Type> GetTypesImplementInterface(Type interfaceType)
        {
            return AppDomain.CurrentDomain.GetAssemblies().SelectMany(x => x.GetTypes())
                .Where(x => interfaceType.IsAssignableFrom(x) && !x.IsInterface && !x.IsAbstract)
                .Select(x => x);
        }
    }
}