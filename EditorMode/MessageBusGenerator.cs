using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using UnityEditor;
using UnityEngine;

namespace com.ez.engine.services.message_bus.editor
{
    internal class MessageBusGenerator : AssetPostprocessor
    {
        private const string GeneratePath = "Scripts/Generated";
        private const string MessageBusFileName = "MessageBusExtensions";

        private static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets, string[] movedAssets, string[] movedFromAssetPaths)
        {
            var isMessageScript = importedAssets.Any(IsMessageClass) ||
                                  deletedAssets.Any(IsMessageClass) ||
                                  movedAssets.Any(IsMessageClass) ||
                                  movedFromAssetPaths.Any(IsMessageClass);

            if (isMessageScript)
            {
                // GenerateCode();
            }
        }

        private static bool IsMessageClass(string path)
        {
            if (path.Contains(".cs"))
            {
                if (File.Exists(path))
                {
                    var lines = File.ReadAllLines(path);
                    foreach (var line in lines)
                    {
                        if (line.Contains(":") && line.Contains("IMessage"))
                        {
                            return true;
                        }
                    }
                }
            }

            return false;
        }

        [MenuItem("Unimob/CodeGen/Message Bus Extensions")]
        public static void GenerateCode()
        {
            var saveFolderPath = Path.Combine(Application.dataPath, GeneratePath);
            var saveFilePath = Path.Combine(saveFolderPath, MessageBusFileName + ".cs");

            if (!Directory.Exists(saveFolderPath))
            {
                Directory.CreateDirectory(saveFolderPath);
            }

            if (File.Exists(saveFilePath))
            {
                File.Delete(saveFilePath);
            }

            if (File.Exists(saveFilePath + ".meta"))
            {
                File.Delete(saveFilePath + ".meta");
            }

            AssetDatabase.Refresh(ImportAssetOptions.ForceUpdate);
            AssetDatabase.SaveAssets();

            var builder = new StringBuilder();
            builder.Append("using System;").Append("\n");
            builder.Append("using UnityEngine;").Append("\n");
            builder.Append("using com.ez.engine.unregister;").Append("\n");
            
            var content = GenerateMessageExtensionsContent(out var namespaces);
            foreach (var ns in namespaces)
            {
                builder.Append($"using {ns};");
                builder.Append("\n");
            }

            if (namespaces.Count > 0)
            {
                builder.Append("\n");
            }

            builder.Append(content);
            File.WriteAllText(saveFilePath, builder.ToString(), Encoding.UTF8);
            AssetDatabase.ImportAsset(Path.Combine("Assets", GeneratePath, $"{MessageBusFileName}.cs"));
            AssetDatabase.Refresh(ImportAssetOptions.ForceUpdate);
            AssetDatabase.SaveAssets();
        }

        private static string GenerateMessageExtensionsContent(out List<string> namespaces)
        {
            namespaces = new List<string>();
            var builder = new StringBuilder();
            builder.Append("namespace com.ez.engine.services.message_bus").Append("\n");
            builder.Append("{").Append("\n");
            var assetPaths = AssetDatabase.GetAllAssetPaths();
            var messages = GetAllTypesImpInterface<IMessage>();
            foreach (var assetPath in assetPaths)
            {
                if (assetPath.Contains(".cs"))
                {
                    foreach (var message in messages)
                    {
                        if (message.Name.Equals(Path.GetFileNameWithoutExtension(assetPath)))
                        {
                            var path = assetPath.Replace("\\", "/");
                            if (File.Exists(path))
                            {
                                builder.Append("\t").Append("///<auto-generated/>").Append("\n");
                                builder.Append("\t").AppendFormat("public static class {0}Extensions", message.Name).Append("\n");
                                builder.Append("\t").Append("{").Append("\n");
                                builder.Append("\t\t").Append(GenerateMessageExtensionsMethod(message)).Append("\n");
                                builder.Append("\t").Append("}").Append("\n");
                                builder.Append("\n");

                                if (!string.IsNullOrEmpty(message.Namespace) && !namespaces.Contains(message.Namespace))
                                {
                                    namespaces.Add(message.Namespace);
                                }
                            }
                        }
                    }
                }
            }

            builder.Append("}");
            return builder.ToString();
        }

        private static string GenerateMessageExtensionsMethod(Type messageType)
        {
            var typeName = messageType.Name;
            return $@"///<auto-generated/>
        public static IUnRegister Register_{typeName}(this IMessageBusService messageBus, Action<{typeName}> listener)
        {{
            return messageBus.Register(listener);
        }}
        
        ///<auto-generated/>
        public static IUnRegister Register_{typeName}(this IMessageBusService messageBus, Action<{typeName}> listener, GameObject unRegisterWhenGameObjectDestroyed)
        {{
            return messageBus.Register(listener).UnRegisterWhenGameObjectDestroyed(unRegisterWhenGameObjectDestroyed);
        }}

        ///<auto-generated/>
        public static void UnRegister_{typeName}(this IMessageBusService messageBus, Action<{typeName}> listener)
        {{
            messageBus.UnRegister(listener);
        }}

        ///<auto-generated/>
        public static void Dispatch_{typeName}(this IMessageBusService messageBus, {typeName} message)
        {{
            messageBus.Dispatch(message);
        }}";
        }

        public static IEnumerable<Type> GetAllTypesImpInterface<TInterface>()
        {
            var results = new List<Type>();
            var types = GetTypesImplementInterface<TInterface>();

            foreach (var type in types)
            {
                if (type.IsGenericType)
                {
                    try
                    {
                        results.AddRange(from typeArgument in type.GetGenericArguments()
                            from typeConstraint in typeArgument.GetGenericParameterConstraints()
                            from genericType in GetAllGenericTypes(type, typeConstraint)
                            select genericType);
                    }
                    catch (StackOverflowException e)
                    {
                        Debug.LogError($"[{nameof(MessageBusGenerator)}] Ignore type {type.Name} that caused stack overflow. {e.Message}");
                    }
                }
                else
                {
                    results.Add(type);
                }
            }

            return results;
        }

        private static IEnumerable<Type> GetAllGenericTypes(Type classType, Type constrainedType)
        {
            var possibleArgumentTypes = GetTypesImplementInterface(constrainedType);
            return possibleArgumentTypes.Select(argumentType => classType.MakeGenericType(argumentType)).ToList();
        }

        private static IEnumerable<Type> GetTypesImplementInterface<TInterface>()
        {
            return AppDomain.CurrentDomain.GetAssemblies().SelectMany(x => x.GetTypes())
                .Where(x => typeof(TInterface).IsAssignableFrom(x) && !x.IsInterface && !x.IsAbstract)
                .Select(x => x);
        }

        private static IEnumerable<Type> GetTypesImplementInterface(Type interfaceType)
        {
            return AppDomain.CurrentDomain.GetAssemblies().SelectMany(x => x.GetTypes())
                .Where(x => interfaceType.IsAssignableFrom(x) && !x.IsInterface && !x.IsAbstract)
                .Select(x => x);
        }

        private static string GetGenericFullName(Type type)
        {
            return type.IsGenericType
                ? Regex.Replace(type.ToString(), @"[\d-]", string.Empty).Replace("`", string.Empty).Replace("[", "<").Replace("]", ">")
                : type.FullName;
        }

        private static string GetPrettyGenericFullName(Type type)
        {
            if (!type.IsGenericType) return type.ToString();
            return GetGenericFullName(type);
        }
    }
}